@inherits LayoutComponentBase
@inject PEngine.ViewModels.GlobalViewModel gvm;

<PageTitle>PEngine</PageTitle>

<div class="page">
    <header>
        <ul class="gnb">
            <li class="top-item">
                <NavLink href="/introduction">Introduction</NavLink>
            </li>
            <li class="top-item">
                <NavLink href="/tags">Tags</NavLink>
            </li>
            <li class="top-item">
                <NavLink href="/terminal">Terminal</NavLink>
            </li>
            <li class="top-item">
                <NavLink href="/guestbook">Guestbook</NavLink>
            </li>
        </ul>
        <ul class="gnb">
            <li class="top-item">
                <form action="/search">
                    <input type="text" name="query" placeholder="Search..."/>
                </form>
            </li>
            <li class="top-item">
                <NavLink href="/login">Login</NavLink>
            </li>
        </ul>
    </header>
    <main>
        <aside>
            <ul class="tree">
                <li class="item">
                    <input type="checkbox" id="node_1" />
                    <label for="node_1">
                        <span>ITEM</span>
                    </label>
                    <ul class="tree">
                        <li class="item">
                            <input type="checkbox" id="node_2" />
                            <label for="node_2">
                                <span>ITEM</span>
                            </label>
                        </li>
                        <li class="item">
                            <input type="checkbox" id="node_3" />
                            <label for="node_3">
                                <span>ITEM</span>
                            </label>
                            <ul class="tree">
                                <li class="item">
                                    <input type="checkbox" id="node_4" />
                                    <label for="node_4">
                                        <span>ITEM</span>
                                    </label>
                                </li>
                                <li class="item">
                                    <input type="checkbox" id="node_5" />
                                    <label for="node_5">
                                        <span>ITEM</span>
                                    </label>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </aside>
        <content>@Body</content>

        @if (IsBusy)
        {
            <Loader  />
        }

        <Pronama />
    </main>
    <footer>
        @CurrentStatusMessage
    </footer>
</div>

@code
{
    private event Action<MainLayout, bool> LoadingStateChanged;
    private event Action<MainLayout, Func<Task>> OnTaskEnqueueRequested;
    private event Action<MainLayout> OnTaskCompleted;

    public System.Collections.Concurrent.ConcurrentQueue<Func<Task>> taskQueues;

    public bool IsBusy => !taskQueues.IsEmpty;
    public string CurrentStatusMessage = "Ready";

    public MainLayout()
    {
        taskQueues = new System.Collections.Concurrent.ConcurrentQueue<Func<Task>>();

        OnTaskEnqueueRequested += async (c, t) =>
        {
            var cts = new CancellationTokenSource();

            taskQueues.Enqueue(t);

            if (taskQueues.Count == 1)
            {
                await Task.Run(t, cts.Token);
            }

            await c.InvokeAsync(c.StateHasChanged);
        };

        OnTaskCompleted += async (c) =>
        {
            if (taskQueues.TryDequeue(out _))
            {
                taskQueues.TryPeek(out var nextTask);

                if (nextTask is not null)
                {
                    await nextTask();
                }
            }

            await c.InvokeAsync(c.StateHasChanged);
        };

        LoadingStateChanged += async (c, s) =>
        {
            await c.InvokeAsync(c.StateHasChanged);
        };

    }

    private void LoadingChange()
    {
        QueueTask(async () =>
        {
            await Task.Delay(3000);
        });
    }

    public void QueueTask(Func<Task> asyncTask)
    {
        Func<Task> wrappedTask = async () =>
        {
            await asyncTask();
            OnTaskCompleted(this);
        };

        OnTaskEnqueueRequested(this, wrappedTask);
    }
}